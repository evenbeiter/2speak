<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      --left-w: 30%;
      --right-w: 70%;
      --card-gap: 8px;
    }
    html,body { height:100%; margin:0; }
    .app {
      display: grid;
      grid-template-columns: var(--left-w) var(--right-w);
      height: 100vh;
      gap: 0;
      background: #f5f6f8;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* 左區 */
    #leftPane {
      border-right: 1px solid #e9ecef;
      display:flex;
      flex-direction:column;
      background: #fff;
      overflow: hidden;
    }
    #leftHeader {
      padding:.6rem;
      border-bottom:1px solid #eee;
      display:flex;
      gap:.5rem;
      align-items:center;
    }
    #leftContent {
      overflow:auto;
      padding:.75rem;
      display:flex;
      flex-direction:column;
      gap:.5rem;
    }
    .day-block {
      border:1px solid #e7e7e7;
      border-radius:6px;
      background:#fafafa;
      padding:.45rem;
    }
    .day-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.5rem;
    }
    .notes-list {
      margin-top:.5rem;
      display:flex;
      flex-direction:column;
      gap:.5rem;
    }
    .daily-card {
      padding:.6rem;
      border-radius:6px;
      border:1px solid #dee2e6;
      background: #fff;
      cursor: grab;
      user-select:none;
    }
    .daily-card.filed {
      background:#f0f0f0;
      opacity:0.7;
    }
    .daily-card pre { margin:0; white-space:pre-wrap; font-family:inherit; font-size:0.95rem; }

    /* 右區 */
    #rightPane {
      padding:.75rem;
      overflow:auto;
    }
    #rightToolbar {
      display:flex;
      gap:.5rem;
      align-items:center;
      margin-bottom:.6rem;
      position:sticky;
      top:0;
      background:linear-gradient(to bottom, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
      z-index:10;
      padding-bottom:.5rem;
    }

    .folders-area {
      display:flex;
      flex-direction:column;
      gap:1rem;
    }

    .folder {
      border:1px solid #e6e6e6;
      border-radius:6px;
      background:#fff;
      overflow:hidden;
    }
    .folder-header {
      display:flex;
      align-items:center;
      gap:.5rem;
      padding:.5rem;
      border-bottom:1px solid #f0f0f0;
    }
    .folder-header .title {
      font-weight:600;
      flex:1;
      min-width:0;
      outline:none;
    }
    .folder-grid {
      padding:.6rem;
      display:grid;
      grid-template-columns: repeat(6, 1fr); /* 每行6個，可根據需求改 */
      gap: var(--card-gap);
      align-items:start;
    }

    .topic-card {
      border:1px solid #e7e7e7;
      padding:.45rem;
      border-radius:6px;
      background:#fff;
      display:flex;
      flex-direction:column;
      gap:.35rem;
      cursor:grab;
      user-select:none;
    }
    .topic-card .title {
      font-size:0.95rem;
      font-weight:600;
      outline:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .topic-card .meta {
      display:flex;
      gap:.35rem;
      align-items:center;
      justify-content:space-between;
      font-size:0.86rem;
      color:#6b7280;
    }
    .topic-card .actions {
      display:flex;
      gap:.25rem;
      justify-content:flex-end;
    }

    /* drop hints */
    .folder.drag-over, .folder-grid.drop-target {
      box-shadow: inset 0 0 0 2px rgba(13,110,253,0.12);
    }
    .topic-card.drag-over {
      outline: 2px dashed rgba(0, 123, 255, 0.35);
    }

    /* check animation */
    .check-anim {
      position:relative;
    }
    .check-anim .check {
      position:absolute;
      right:6px;
      top:6px;
      background: #28a745;
      color:#fff;
      width:26px;
      height:26px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      transform: scale(0);
      transition: transform .18s ease;
      font-weight:700;
    }
    .check-anim.show .check {
      transform: scale(1);
    }

    /* modal list */
    .modal-card {
      border:1px solid #e9e9e9;
      padding:.45rem;
      border-radius:6px;
      background:#fff;
      margin-bottom:.4rem;
      cursor:grab;
    }
    .modal-list { max-height:40vh; overflow:auto; padding:.6rem; border:1px solid #f0f0f0; border-radius:6px; background:#fafafa; }

    /* responsive */
    @media (max-width:900px) {
      .app { grid-template-columns: 100%; grid-auto-rows: 40vh 60vh; }
      .folder-grid { grid-template-columns: repeat(3, 1fr); }
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- LEFT -->
    <section id="leftPane">
      <div id="leftHeader">
        <h5 class="m-0">每日筆記</h5>
        <div class="ms-auto d-flex gap-2">
          <button id="refreshDailyBtn" class="btn btn-sm btn-outline-secondary">重新載入</button>
        </div>
      </div>

      <div id="leftContent">
        <!-- 動態載入 day-block（日期 + 展開 notes list） -->
      </div>
      <div style="padding:.5rem;border-top:1px solid #eee;background:#fff">
        <small class="text-muted">拖曳單則筆記到右側任一主題小標卡片以「複製」內容。</small>
      </div>
    </section>

    <!-- RIGHT -->
    <section id="rightPane">
      <div id="rightToolbar">
        <button id="addFolderBtn" class="btn btn-sm btn-primary">新增資料夾</button>
        <button id="saveAllBtn" class="btn btn-sm btn-success">儲存：folders 順序 + 所有主題內容 + 已標記每日筆記</button>
        <div class="ms-auto text-muted small">注意：儲存前變更只暫存在前端</div>
      </div>

      <div id="foldersArea" class="folders-area">
        <!-- folders 動態生成 -->
      </div>
    </section>
  </div>

  <!-- Modal：編輯主題小標內的筆記（title + cards list） -->
  <div class="modal fade" id="editFileModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h6 class="modal-title">編輯主題筆記</h6>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="mb-2">
            <label class="form-label">主題小標（檔名）</label>
            <input id="modalFileTitle" class="form-control form-control-sm" />
          </div>
          <div class="mb-2">
            <label class="form-label">筆記列表（可拖曳排序、每則為可編輯）</label>
            <div id="modalList" class="modal-list"></div>
            <div class="d-flex gap-2 mt-2">
              <button id="modalAddCardBtn" class="btn btn-sm btn-outline-secondary">新增卡片</button>
              <div class="ms-auto text-muted small align-self-center">使用「複製」可快速複製卡片內容到剪貼區，再在其他主題按「貼上」。</div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button id="modalConfirmBtn" class="btn btn-primary">確定（暫存到前端）</button>
          <button class="btn btn-secondary" data-bs-dismiss="modal">關閉</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* =======================
   Config / Backend base
   ======================= */
const BACKEND_BASE = "https://newsbeiter.onrender.com"; // <- 改成你的 Render domain

/* =======================
   API 規格（前端依賴）
   - GET  /api/daily/list                      -> [{date:"20250826", filename:"20250826.txt"}, ...] (倒序)
   - GET  /api/daily/:date                     -> { notes: [ {id, content, filed?}, ... ] }  // notes array
   - POST /api/daily/updateFiled               -> body: { updates: [{id, filed:'y'|'n'}...] } -> {ok:true}
   - GET  /api/topics/index                    -> { index: [ "FolderA/File1.txt", "FolderB/File2.txt", ... ] } // index.json
   - GET  /api/topics/folder/:folder/files    -> { files: [ "File1.txt", ... ] } (順序)
   - GET  /api/topics/file?path=FolderA/File1.txt -> { title:"File1", cards:[ "note1", "note2", ... ] }
   - POST /api/topics/folders/order           -> body: { index: [ "FolderA/File1.txt", ... ] } -> {ok:true}
   - POST /api/topics/saveFile                -> body: { path:"FolderA/File1.txt", title:"...", cards:[..] } -> {ok:true}
   - POST /api/topics/addFolder               -> body: { folder:"NewFolder" } -> {ok:true}
   - POST /api/topics/addFile                 -> body: { folder:"F", filename:"X.txt" } -> {ok:true}
   (後端以 Octokit/GitHub REST 實作，或同樣路徑命名)
*/
async function api(path, options={}) {
  const url = BACKEND_BASE + path;
  try {
    const res = await fetch(url, Object.assign({
      headers: {'Content-Type':'application/json'}
    }, options));
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  } catch (err) {
    console.warn("API 失敗，使用 Demo 假資料以維持前端互動：", path, err);
    return demoFallback(path, options);
  }
}

/* Demo fallback (使前端可離線測試)
   注意：demoFallback 回傳物件格式模擬實際 API（用 then-able 的方式，以維持 earlier code 風格）
*/
function demoFallback(path, options) {
  // minimal, immediate resolved value
  if (path === "/api/daily/list") {
    return { then: (cb) => cb([
      {date:"20250827", filename:"20250827.txt"},
      {date:"20250826", filename:"20250826.txt"},
      {date:"20250825", filename:"20250825.txt"}
    ]) };
  }
  if (path.startsWith("/api/daily/")) {
    const date = path.split("/").pop();
    return { then: (cb) => cb({
      notes: [
        { id:`${date}-1`, content:`${date} — 筆記 A\n細節 A1\n細節 A2`, filed:'n' },
        { id:`${date}-2`, content:`${date} — 筆記 B\n細節 B1\n細節 B2`, filed:'n' },
        { id:`${date}-3`, content:`${date} — 筆記 C\n細節 C1\n細節 C2`, filed:'n' }
      ]
    })};
  }
  if (path === "/api/topics/index") {
    return { then: (cb) => cb({ index: ["Macro/宏觀一.txt", "Equities/SPX筆記.txt", "Tech/AI簡介.txt"] }) };
  }
  if (path.startsWith("/api/topics/folder/") && path.endsWith("/files")) {
    const folder = decodeURIComponent(path.split("/")[3]);
    const files = folder === "Macro" ? ["宏觀一.txt","利率觀察.txt"]
      : folder === "Equities" ? ["SPX筆記.txt","個股觀察.txt"]
      : ["AI簡介.txt","半導體趨勢.txt"];
    return { then: (cb) => cb({ files }) };
  }
  if (path.startsWith("/api/topics/file")) {
    return { then: (cb) => cb({ title:"示例檔名", cards:["重點一\n細節","重點二\n細節","結論"] }) };
  }
  if (path.endsWith("/order") || path.endsWith("/saveFile") || path === "/api/daily/updateFiled" || path === "/api/topics/addFolder" || path === "/api/topics/addFile") {
    return { then: (cb) => cb({ ok:true }) };
  }
  return { then: (cb) => cb({}) };
}

/* =========================
   全域狀態與 DOM references
   ========================= */
const leftContent = document.getElementById("leftContent");
const foldersArea = document.getElementById("foldersArea");
const addFolderBtn = document.getElementById("addFolderBtn");
const saveAllBtn = document.getElementById("saveAllBtn");
const refreshDailyBtn = document.getElementById("refreshDailyBtn");

let dailyDataCache = {}; // date -> notes array
let indexList = [];      // array of "Folder/File.txt" path strings (順序)
let folderMap = {};      // folderName -> { files: [filenames], fileData: { filename -> { title, cards, modified? } } }
let modalState = { path:null }; // currently editing file path
let clipboardCard = null; // 暫存複製的卡片內容（字串）
let pendingFileChanges = new Set(); // paths modified in front-end not yet saved
let pendingFiledUpdates = {}; // id -> 'y'/'n' to send when user clicks saveAllBtn

/* =========================
   載入並渲染每日筆記（左）
   ========================= */
async function loadDailyList() {
  leftContent.innerHTML = "";
  const list = await api("/api/daily/list");
  const days = list || [];
  for (const item of days) {
    const dayBlock = createDayBlock(item);
    leftContent.appendChild(dayBlock);
  }
}
function createDayBlock(item) {
  const wrap = document.createElement("div");
  wrap.className = "day-block";
  const header = document.createElement("div");
  header.className = "day-header";
  const title = document.createElement("div");
  title.textContent = `${item.date}  ${item.filename}`;
  const btn = document.createElement("button");
  btn.className = "btn btn-sm btn-outline-secondary";
  btn.textContent = "展開";
  btn.addEventListener("click", async ()=>{
    const notesWrap = wrap.querySelector(".notes-list");
    if (notesWrap) {
      notesWrap.remove();
      btn.textContent = "展開";
      return;
    }
    // load notes for date
    const data = await api(`/api/daily/${item.date}`);
    const notes = data?.notes || [];
    dailyDataCache[item.date] = notes; // store
    const listEl = document.createElement("div");
    listEl.className = "notes-list";
    notes.forEach(n=>{
      const c = createDailyCard(item.date, n);
      listEl.appendChild(c);
    });
    wrap.appendChild(listEl);
    btn.textContent = "收合";
  });
  header.appendChild(title);
  header.appendChild(btn);
  wrap.appendChild(header);
  return wrap;
}
function createDailyCard(date, note) {
  const div = document.createElement("div");
  div.className = "daily-card";
  div.dataset.noteId = note.id;
  div.dataset.date = date;
  div.dataset.filed = note.filed || 'n';
  if (note.filed === 'y') div.classList.add('filed');

  const pre = document.createElement("pre");
  pre.textContent = note.content;
  div.appendChild(pre);

  // bottom controls: filed toggle
  const ctrl = document.createElement("div");
  ctrl.style.display="flex";
  ctrl.style.justifyContent="space-between";
  ctrl.style.marginTop=".4rem";
  const meta = document.createElement("small");
  meta.className="text-muted";
  meta.textContent = note.id;
  const rightBtns = document.createElement("div");
  rightBtns.style.display="flex";
  rightBtns.style.gap="6px";

  const filedBtn = document.createElement("button");
  filedBtn.className = "btn btn-sm btn-outline-secondary";
  filedBtn.textContent = note.filed==='y' ? "取消已歸檔" : "標記為已歸檔";
  filedBtn.addEventListener("click", ()=>{
    const newv = div.dataset.filed === 'y' ? 'n' : 'y';
    div.dataset.filed = newv;
    div.classList.toggle('filed', newv==='y');
    filedBtn.textContent = newv==='y' ? "取消已歸檔" : "標記為已歸檔";
    // register pending change
    pendingFiledUpdates[note.id] = newv;
  });
  rightBtns.appendChild(filedBtn);

  ctrl.appendChild(meta);
  ctrl.appendChild(rightBtns);
  div.appendChild(ctrl);

  // drag - copy behavior from left
  div.draggable = true;
  div.addEventListener("dragstart", (e)=>{
    // payload: indicate source daily note; include id & content
    e.dataTransfer.setData("application/json", JSON.stringify({
      type:"daily-note",
      id: note.id,
      date,
      content: note.content
    }));
    e.dataTransfer.effectAllowed = "copy";
  });

  return div;
}

/* =========================
   載入並渲染 folders（右）
   ========================= */
async function loadIndexAndFolders() {
  foldersArea.innerHTML = "";
  const idx = await api("/api/topics/index");
  indexList = idx?.index || [];
  // Build folderMap from indexList:
  folderMap = {};
  for (const path of indexList) {
    // path = "FolderName/FileName.txt"
    const seg = path.split("/");
    const folder = seg[0];
    const file = seg.slice(1).join("/");
    if (!folderMap[folder]) folderMap[folder] = { files: [], fileData: {} };
    folderMap[folder].files.push(file);
    // leave fileData empty (lazy load)
  }
  renderFolders();
}
function renderFolders() {
  foldersArea.innerHTML = "";
  for (const folderName of Object.keys(folderMap)) {
    const folderEl = createFolderElement(folderName);
    foldersArea.appendChild(folderEl);
  }
  // make folders reorderable
  makeFoldersReorderable();
}
function createFolderElement(folderName) {
  const container = document.createElement("div");
  container.className = "folder";
  container.dataset.folder = folderName;

  // header
  const header = document.createElement("div");
  header.className = "folder-header";
  header.draggable = true;
  header.addEventListener("dragstart", (e)=>{
    e.dataTransfer.setData("text/folder-drag", folderName);
    e.dataTransfer.effectAllowed = "move";
  });
  header.addEventListener("dragover", (e)=>{ e.preventDefault(); });
  header.addEventListener("drop", (e)=>{
    e.preventDefault();
    const from = e.dataTransfer.getData("text/folder-drag");
    if (!from || from === folderName) return;
    // reorder in DOM
    const fromEl = [...foldersArea.children].find(n => n.dataset.folder === from);
    foldersArea.insertBefore(fromEl, container);
  });

  const title = document.createElement("div");
  title.className = "title";
  title.contentEditable = true;
  title.textContent = folderName;
  title.addEventListener("blur", (e)=>{
    const newName = title.textContent.trim();
    if (!newName) {
      title.textContent = folderName;
      alert("名稱不可為空");
      return;
    }
    // rename in folderMap: (simple approach) change key
    if (newName !== folderName) {
      if (folderMap[newName]) {
        alert("已存在同名資料夾");
        title.textContent = folderName;
        return;
      }
      folderMap[newName] = folderMap[folderName];
      delete folderMap[folderName];
      // update indexList paths: replace prefix
      indexList = indexList.map(p => p.startsWith(folderName + "/") ? p.replace(folderName + "/", newName + "/") : p);
      // re-render
      setTimeout(loadIndexAndFolders, 0);
    }
  });

  const tools = document.createElement("div");
  tools.style.display="flex";
  tools.style.gap="6px";
  const addFileBtn = document.createElement("button");
  addFileBtn.className = "btn btn-sm btn-outline-primary";
  addFileBtn.textContent = "新增主題小標";
  addFileBtn.addEventListener("click", async ()=>{
    const filename = prompt("請輸入主題小標（檔名），例如：MyNote.txt");
    if (!filename) return;
    // create empty file in folderMap (front-end)
    folderMap[folderName].files.push(filename);
    folderMap[folderName].fileData[filename] = { title: filename.replace(/\.txt$/,""), cards: [], modified:true };
    indexList.push(`${folderName}/${filename}`);
    renderFolders();
  });
  const delFolderBtn = document.createElement("button");
  delFolderBtn.className = "btn btn-sm btn-outline-danger";
  delFolderBtn.textContent = "刪除資料夾";
  delFolderBtn.addEventListener("click", ()=>{
    if (!confirm(`確定要刪除資料夾 ${folderName} 及其所有檔案？（此操作會在你按下「儲存」時同步到 repo）`)) return;
    // remove from folderMap and update indexList
    delete folderMap[folderName];
    indexList = indexList.filter(p => !p.startsWith(folderName + "/"));
    renderFolders();
  });

  tools.appendChild(addFileBtn);
  tools.appendChild(delFolderBtn);

  header.appendChild(title);
  header.appendChild(tools);

  // grid for cards
  const grid = document.createElement("div");
  grid.className = "folder-grid";
  grid.dataset.folder = folderName;
  // load files from folderMap
  const files = folderMap[folderName].files || [];
  files.forEach(fn=>{
    const card = createTopicCard(folderName, fn);
    grid.appendChild(card);
  });

  // allow drop from left (daily-note copy) and move between grids
  grid.addEventListener("dragover", (e)=>{ e.preventDefault(); grid.classList.add("drop-target"); });
  grid.addEventListener("dragleave", ()=> grid.classList.remove("drop-target"));
  grid.addEventListener("drop", (e)=>{
    e.preventDefault();
    grid.classList.remove("drop-target");
    try {
      const txt = e.dataTransfer.getData("application/json");
      if (txt) {
        const payload = JSON.parse(txt);
        if (payload.type === "daily-note") {
          // copy this daily note content to the target folder as appending to a chosen file:
          // Default behavior: 若拖放在 grid 空白區，會新建一檔（ask user for filename），或使用最近一個檔？
          // For simplicity：提示使用者把內容複製到哪個主題小標（選擇）
          handleCopyDailyToFolder(payload, folderName);
          return;
        }
      }
      // handle move of topic-card between folders
      const mv = e.dataTransfer.getData("text/topic-move");
      if (mv) {
        const info = JSON.parse(mv); // {fromFolder, filename}
        const fromGrid = [...foldersArea.querySelectorAll(".folder-grid")].find(g=>g.dataset.folder===info.fromFolder);
        if (!fromGrid) return;
        // find card element by attribute data-filename
        const cardEl = fromGrid.querySelector(`.topic-card[data-filename="${cssEscape(info.filename)}"]`);
        if (!cardEl) return;
        // append to target grid
        grid.appendChild(cardEl);
        // update folderMap
        const idxFrom = folderMap[info.fromFolder].files.indexOf(info.filename);
        if (idxFrom >= 0) folderMap[info.fromFolder].files.splice(idxFrom,1);
        folderMap[folderName].files.push(info.filename);
        // update indexList
        indexList = indexList.map(p => p === `${info.fromFolder}/${info.filename}` ? `${folderName}/${info.filename}` : p);
      }
    } catch (err) {
      console.error(err);
    }
  });

  container.appendChild(header);
  container.appendChild(grid);
  return container;
}

// create topic-card element (visual), data-filename used for identification
function createTopicCard(folderName, filename) {
  const card = document.createElement("div");
  card.className = "topic-card";
  card.dataset.folder = folderName;
  card.dataset.filename = filename;
  card.draggable = true;

  const title = document.createElement("div");
  title.className = "title";
  title.contentEditable = true;
  title.textContent = filename.replace(/\.txt$/,"");
  title.addEventListener("blur", ()=>{
    const newName = title.textContent.trim();
    if (!newName) {
      title.textContent = filename.replace(/\.txt$/,"");
      alert("主題小標不可為空");
      return;
    }
    // renaming filename locally: replace filename in folderMap and indexList
    const newFileName = newName.endsWith(".txt") ? newName : (newName + ".txt");
    if (newFileName === filename) return;
    // check duplicate
    if (folderMap[folderName].files.includes(newFileName)) {
      alert("已存在同名檔案");
      title.textContent = filename.replace(/\.txt$/,"");
      return;
    }
    // rename in folderMap
    const idx = folderMap[folderName].files.indexOf(filename);
    if (idx >= 0) folderMap[folderName].files[idx] = newFileName;
    folderMap[folderName].fileData[newFileName] = folderMap[folderName].fileData[filename] || { title:newName, cards: [] };
    delete folderMap[folderName].fileData[filename];
    // update indexList
    indexList = indexList.map(p => p === `${folderName}/${filename}` ? `${folderName}/${newFileName}` : p);
    // update card's dataset
    card.dataset.filename = newFileName;
  });

  // meta area with actions
  const meta = document.createElement("div");
  meta.className = "meta";
  const leftinfo = document.createElement("div");
  leftinfo.textContent = ""; // placeholder

  const actions = document.createElement("div");
  actions.className = "actions";

  const openBtn = document.createElement("button");
  openBtn.className = "btn btn-sm btn-outline-primary";
  openBtn.textContent = "打開筆記";
  openBtn.addEventListener("click", ()=> openFileModal(folderName, card.dataset.filename));

  const delBtn = document.createElement("button");
  delBtn.className = "btn btn-sm btn-outline-danger";
  delBtn.textContent = "刪除";
  delBtn.addEventListener("click", ()=>{
    if (!confirm(`確定要刪除 ${card.dataset.filename} 嗎？（此變更會在你按上方「儲存」時同步至 repo）`)) return;
    // remove locally
    const arr = folderMap[folderName].files;
    const i = arr.indexOf(card.dataset.filename);
    if (i>=0) arr.splice(i,1);
    delete folderMap[folderName].fileData[card.dataset.filename];
    card.remove();
    // update indexList
    indexList = indexList.filter(p => p !== `${folderName}/${card.dataset.filename}`);
  });

  const pasteBtn = document.createElement("button");
  pasteBtn.className = "btn btn-sm btn-outline-success";
  pasteBtn.textContent = "貼上";
  pasteBtn.addEventListener("click", ()=>{
    if (!clipboardCard) {
      alert("目前剪貼區沒有內容");
      return;
    }
    // if fileData not loaded, create placeholder
    if (!folderMap[folderName].fileData[card.dataset.filename]) {
      folderMap[folderName].fileData[card.dataset.filename] = { title: card.dataset.filename.replace(/\.txt$/,""), cards: [] };
    }
    folderMap[folderName].fileData[card.dataset.filename].cards.push(clipboardCard);
    folderMap[folderName].fileData[card.dataset.filename].modified = true;
    pendingFileChanges.add(`${folderName}/${card.dataset.filename}`);
    // briefly show check animation on card
    animateCheckOnCard(card);
  });

  actions.appendChild(openBtn);
  actions.appendChild(pasteBtn);
  actions.appendChild(delBtn);

  meta.appendChild(leftinfo);
  meta.appendChild(actions);

  card.appendChild(title);
  card.appendChild(meta);

  // drag behavior for moving topic-card between grids
  card.addEventListener("dragstart", (e)=>{
    e.dataTransfer.setData("text/topic-move", JSON.stringify({ fromFolder: folderName, filename: card.dataset.filename }));
    e.dataTransfer.effectAllowed = "move";
    // also allow set for position drag within same grid
    e.stopPropagation();
  });

  // accept drop inside card to reorder (insert before)
  card.addEventListener("dragover", (e)=>{
    e.preventDefault();
    card.classList.add("drag-over");
  });
  card.addEventListener("dragleave", ()=> card.classList.remove("drag-over"));
  card.addEventListener("drop", (e)=>{
    e.preventDefault();
    card.classList.remove("drag-over");
    const mv = e.dataTransfer.getData("text/topic-move");
    if (mv) {
      const info = JSON.parse(mv);
      // find source card element
      const fromGrid = [...foldersArea.querySelectorAll(".folder-grid")].find(g=>g.dataset.folder===info.fromFolder);
      if (!fromGrid) return;
      const fromCard = fromGrid.querySelector(`.topic-card[data-filename="${cssEscape(info.filename)}"]`);
      if (!fromCard) return;
      // insert before this
      card.parentElement.insertBefore(fromCard, card);
      // update folderMap arrays accordingly
      const fromArr = folderMap[info.fromFolder].files;
      const iFrom = fromArr.indexOf(info.filename);
      if (iFrom >= 0) fromArr.splice(iFrom,1);
      const toArr = folderMap[folderName].files;
      const insertIndex = [...card.parentElement.children].indexOf(card);
      toArr.splice(insertIndex,0,info.filename);
      // update indexList paths
      indexList = indexList.filter(p => p !== `${info.fromFolder}/${info.filename}`);
      // insert at position in indexList corresponding to folderName region (after folderName/)
      // Simplify: append to end then reorder when saving folder order
      indexList.push(`${folderName}/${info.filename}`);
    }
  });

  return card;
}

function cssEscape(str){
  return String(str).replace(/([ #;?%&,.+*~\':"!\^$\[\]()=>|\/@])/g,'\\$1');
}
function animateCheckOnCard(card) {
  if (!card.classList.contains('check-anim')) {
    card.classList.add('check-anim');
    const chk = document.createElement("div");
    chk.className = "check";
    chk.textContent = "✓";
    card.appendChild(chk);
    setTimeout(()=> card.classList.add('show'), 20);
    setTimeout(()=> {
      card.classList.remove('show');
      chk.remove();
      card.classList.remove('check-anim');
    }, 1200);
  }
}

/* =========================
   handle copy daily -> folder (user dragged a daily-note into a folder grid)
   將 daily note 複製到某 folder 的某檔（讓使用者選或新建）
   ========================= */
async function handleCopyDailyToFolder(payload, targetFolder) {
  // payload: {type:"daily-note", id, date, content}
  // ask user which file in targetFolder to append to (or create new)
  const files = folderMap[targetFolder].files || [];
  let choice;
  if (files.length === 0) {
    if (!confirm(`資料夾 ${targetFolder} 尚無檔案，是否建立新檔並加入筆記？`)) return;
    const fname = prompt("請輸入新檔名（含 .txt）", "newnote.txt");
    if (!fname) return;
    folderMap[targetFolder].files.push(fname);
    folderMap[targetFolder].fileData[fname] = { title: fname.replace(/\.txt$/,""), cards: [] };
    indexList.push(`${targetFolder}/${fname}`);
    choice = fname;
  } else {
    // ask user to pick one (簡單 prompt listing files)
    const sel = prompt(`選擇要加入到哪個檔案（輸入數字）\n${files.map((f,i)=> `${i+1}. ${f}`).join("\n")}\n輸入 N 以新檔`, "1");
    if (!sel) return;
    if (sel.toUpperCase() === 'N') {
      const fname = prompt("請輸入新檔名（含 .txt）", "newnote.txt");
      if (!fname) return;
      folderMap[targetFolder].files.push(fname);
      folderMap[targetFolder].fileData[fname] = { title: fname.replace(/\.txt$/,""), cards: [] };
      indexList.push(`${targetFolder}/${fname}`);
      choice = fname;
    } else {
      const idx = parseInt(sel,10)-1;
      if (isNaN(idx) || idx < 0 || idx >= files.length) { alert("選擇錯誤"); return; }
      choice = files[idx];
    }
  }
  // ensure fileData
  if (!folderMap[targetFolder].fileData[choice]) folderMap[targetFolder].fileData[choice] = { title: choice.replace(/\.txt$/,""), cards: [] };
  // append note content to fileData.cards
  const text = payload.content.trim();
  folderMap[targetFolder].fileData[choice].cards.push(text);
  folderMap[targetFolder].fileData[choice].modified = true;
  pendingFileChanges.add(`${targetFolder}/${choice}`);
  // mark left daily as filed
  // find left card element by id
  const leftCard = document.querySelector(`.daily-card[data-note-id="${payload.id}"]`);
  if (leftCard) {
    leftCard.dataset.filed = 'y';
    leftCard.classList.add('filed');
    // update pendingFiledUpdates
    pendingFiledUpdates[payload.id] = 'y';
  }
  // show animation on the target card (if present in grid)
  const targetGrid = [...foldersArea.querySelectorAll(".folder-grid")].find(g=>g.dataset.folder===targetFolder);
  if (targetGrid) {
    // find card element with filename == choice
    const cardEl = targetGrid.querySelector(`.topic-card[data-filename="${cssEscape(choice)}"]`);
    if (cardEl) animateCheckOnCard(cardEl);
  }
  alert("已將該則每日筆記複製到主題筆記（暫存在前端，請記得按右上「儲存」同步到 repo）");
  renderFolders(); // re-render to show new card if needed
}

/* =========================
   Make folders reorderable (simple)
   ========================= */
function makeFoldersReorderable(){
  const folderEls = [...foldersArea.children];
  folderEls.forEach(el=>{
    // already have drag handlers on header; we also accept drop on entire folder
    el.addEventListener("dragover", (e)=> e.preventDefault());
    el.addEventListener("drop", (e)=>{
      e.preventDefault();
      const from = e.dataTransfer.getData("text/folder-drag");
      if (!from) return;
      const fromEl = [...foldersArea.children].find(n => n.dataset.folder === from);
      if (!fromEl) return;
      foldersArea.insertBefore(fromEl, el);
    });
  });
}

/* =========================
   Open modal to edit a specific file
   ========================= */
//const bsModal = new bootstrap.Modal(document.getElementById("editFileModal"));
const bsModal = document.getElementById("editFileModal");
const modalFileTitle = document.getElementById("modalFileTitle");
const modalList = document.getElementById("modalList");
const modalAddCardBtn = document.getElementById("modalAddCardBtn");
const modalConfirmBtn = document.getElementById("modalConfirmBtn");

async function openFileModal(folderName, filename) {
  const path = `${folderName}/${filename}`;
  modalState.path = path;
  // load file data if not loaded
  let fd = folderMap[folderName].fileData[filename];
  if (!fd) {
    // fetch from backend
    const r = await api(`/api/topics/file?path=${encodeURIComponent(path)}`);
    const title = r?.title || filename.replace(/\.txt$/,"");
    const cards = r?.cards || [];
    fd = { title, cards: Array.from(cards), modified:false };
    folderMap[folderName].fileData[filename] = fd;
  }
  // populate modal
  modalFileTitle.value = fd.title || filename.replace(/\.txt$/,"");
  modalList.innerHTML = "";
  fd.cards.forEach((c,i)=>{
    const mc = createModalCard(c, i);
    modalList.appendChild(mc);
  });
  //bsModal.show();
  bsModal.style.display='block';
}

function createModalCard(text, idx) {
  const m = document.createElement("div");
  m.className = "modal-card";
  m.draggable = true;
  m.dataset.index = idx;

  const txt = document.createElement("div");
  txt.contentEditable = true;
  txt.style.whiteSpace = "pre-wrap";
  txt.style.minHeight = "36px";
  txt.textContent = text;

  const actions = document.createElement("div");
  actions.style.display="flex";
  actions.style.justifyContent="space-between";
  actions.style.marginTop=".35rem";

  const left = document.createElement("div");
  left.className="text-muted small";
  left.textContent = `#${idx+1}`;

  const right = document.createElement("div");
  right.style.display="flex";
  right.style.gap="6px";

  const copyBtn = document.createElement("button");
  copyBtn.className = "btn btn-sm btn-outline-secondary";
  copyBtn.textContent = "複製";
  copyBtn.addEventListener("click", ()=>{
    clipboardCard = txt.innerText;
    alert("已複製此卡片到剪貼區（可在其他主題按貼上）");
  });

  const delBtn = document.createElement("button");
  delBtn.className = "btn btn-sm btn-outline-danger";
  delBtn.textContent = "刪除";
  delBtn.addEventListener("click", ()=>{
    if (!confirm("確定刪除此卡片？")) return;
    m.remove();
  });

  right.appendChild(copyBtn);
  right.appendChild(delBtn);

  actions.appendChild(left);
  actions.appendChild(right);

  m.appendChild(txt);
  m.appendChild(actions);

  // draggable reorder inside modalList
  m.addEventListener("dragstart", (e)=>{
    e.dataTransfer.setData("text/modal-card", m.dataset.index);
    e.dataTransfer.effectAllowed = "move";
  });
  m.addEventListener("dragover", (e)=> { e.preventDefault(); m.style.outline = "2px dashed rgba(0,0,0,0.12)"; });
  m.addEventListener("dragleave", ()=> m.style.outline = "none");
  m.addEventListener("drop", (e)=>{
    e.preventDefault();
    m.style.outline = "none";
    const fromIndex = e.dataTransfer.getData("text/modal-card");
    if (fromIndex == null) return;
    // reorder elements
    const fromEl = modalList.querySelector(`.modal-card[data-index="${fromIndex}"]`);
    if (!fromEl) return;
    modalList.insertBefore(fromEl, m);
    // reindex data-index
    [...modalList.children].forEach((c,i)=> c.dataset.index = i);
  });

  return m;
}

/* modal add card */
modalAddCardBtn.addEventListener("click", ()=>{
  const newCard = createModalCard("", modalList.children.length);
  modalList.appendChild(newCard);
});

/* modal confirm: store changes into folderMap fileData (temporary) */
modalConfirmBtn.addEventListener("click", ()=>{
  const path = modalState.path;
  if (!path) return;
  const [folder, ...rest] = path.split("/");
  const filename = rest.join("/");
  const title = modalFileTitle.value.trim() || filename.replace(/\.txt$/,"");
  const cards = [...modalList.children].map(c => c.querySelector("div").innerText);
  folderMap[folder].fileData[filename] = { title, cards, modified:true };
  pendingFileChanges.add(path);
  // update visual: no direct change to topic-card label except title rename on blur
  //bsModal.hide();
  bsModal.style.display='none';
  alert("已在前端暫存編輯（尚未寫入 repo），請按右上「儲存」同步到 GitHub。");
});

/* =========================
   Top-level actions
   ========================= */
addFolderBtn.addEventListener("click", async ()=>{
  const name = prompt("請輸入資料夾名稱（主題大標）");
  if (!name) return;
  if (folderMap[name]) { alert("已存在同名資料夾"); return; }
  // create locally
  folderMap[name] = { files: [], fileData: {} };
  indexList.push(`${name}/`); // placeholder (will be cleaned up)
  // also call backend to create folder if desired
  await api("/api/topics/addFolder", { method:"POST", body: JSON.stringify({ folder: name }) });
  renderFolders();
});

saveAllBtn.addEventListener("click", async ()=>{
  // a) 儲存 folders 最新順序到 index.json
  // gather folder order from DOM
  const folderOrder = [...foldersArea.children].map(f => f.dataset.folder).filter(Boolean);
  // build new index array by iterating folderOrder and for each folder, append its files order
  const newIndex = [];
  for (const fd of folderOrder) {
    const files = folderMap[fd]?.files || [];
    for (const f of files) {
      if (f && f.trim()) newIndex.push(`${fd}/${f}`);
    }
  }
  // call API to save index.json
  await api("/api/topics/folders/order", { method:"POST", body: JSON.stringify({ index: newIndex }) });

  // b) 儲存所有被修改過(暫存)的主題小標內容
  for (const path of Array.from(pendingFileChanges)) {
    const [folder, ...rest] = path.split("/");
    const filename = rest.join("/");
    const fd = folderMap[folder]?.fileData?.[filename];
    if (!fd) continue;
    await api("/api/topics/saveFile", {
      method: "POST",
      body: JSON.stringify({ path, title: fd.title || filename.replace(/\.txt$/,""), cards: fd.cards || [] })
    });
    pendingFileChanges.delete(path);
  }

  // c) 儲存已標記的每日筆記 filed updates
  const updates = Object.entries(pendingFiledUpdates).map(([id, filed])=> ({ id, filed }));
  if (updates.length > 0) {
    await api("/api/daily/updateFiled", { method:"POST", body: JSON.stringify({ updates }) });
    pendingFiledUpdates = {}; // reset
  }

  alert("已發送儲存請求（folders index, 修改過的主題檔案, 與每日已標記列表）。若有錯誤請查看 console log。");
  // reload index to refresh UI
  await loadIndexAndFolders();
});

/* =========================
   misc helpers & init
   ========================= */
function cssEscapeSelector(s) {
  return s.replace(/([ #;?%&,.+*~\':"!\^$\[\]()=>|\/@])/g,'\\$1');
}

/* initial load */
refreshDailyBtn.addEventListener("click", loadDailyList);
loadDailyList();
loadIndexAndFolders();

</script>

<!-- bootstrap js -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>